"""
A policy from TuRBO algorithm for deciding where to sample next.
"""
mutable struct TurboPolicy <: Policy
    # for each TR use candidate_size many points to approximate a sample function
    # drawn from the posterior (Thompson sample)
    candidate_size::Int
    prob_of_perturbation::Float64
end

# TODO: allow to configure candidate_size
function TurboPolicy(dimension)
    # default value from the TuRBO paper
    candidate_size = min(100 * dimension, 5000)
    prob_of_perturbation = min(20.0 / dimension, 1)
    TurboPolicy(candidate_size, prob_of_perturbation)
end

# note: policies are callable objects
function (policy::TurboPolicy)(dsm::Turbo)
    next_points = Vector{Vector{Float64}}(undef, dsm.batch_size)
    for i in 1:(dsm.batch_size)
        #    sample a function from the posterior for each TR (discretized version on
        #    candidate_size many points generated by modified Sobol sequence)
        combined_xs = Vector{Vector{Float64}}()
        combined_ys = Vector{Float64}()
        for j in 1:(dsm.n_surrogates)
            tr_xs = turbo_policy_seq(dsm, policy.candidate_size,
                                     policy.prob_of_perturbation, j)
            # calculate approximation function values at tr_xs via the j-th surrogate
            tr_ys = (dsm.surrogates[j]).(tr_xs)
            append!(combined_xs, tr_xs)
            append!(combined_ys, tr_ys)
        end
        next_points[i] = combined_xs[argmax(combined_ys)]
    end
    next_points
end

function turbo_policy_seq(dsm::Turbo, candidate_size, prob_of_perturbation, j)
    xs = []
    # following the construction from the paper: supplement material part D; and python implementation
    # TODO: scrambled Sobol?
    for perturbation in (from_unit_cube(next!(dsm.sobol_generator), dsm.trs[j].lb,
                                        dsm.trs[j].ub) for _ in 1:candidate_size)
        x = copy(dsm.trs[j].center)
        # each index is chosen with prob. prob_of_perturbation
        for i in 1:length(x)
            if rand() <= prob_of_perturbation
                x[i] = perturbation[i]
            end
        end
        push!(xs, x)
    end
    xs
end
